<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<style>
  body {
    padding: 100px;
    width: 1000px;
    margin: auto;
    text-align: left;
    font-weight: 300;
    font-family: 'Open Sans', sans-serif;
    color: #121212;
  }
  h1, h2, h3, h4 {
    font-family: 'Source Sans Pro', sans-serif;
  }
</style>
<title>CS 184 Rasterizer</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link href="https://fonts.googleapis.com/css?family=Open+Sans|Source+Sans+Pro" rel="stylesheet">
</head>


<body>

<h1 align="middle">CS 184: Computer Graphics and Imaging, Spring 2023</h1>
<h1 align="middle">Project 1: Rasterizer</h1>
<h2 align="middle">Srisai Nachuri, Maddy Chen, CS184</h2>

<br><br>

<div>

<h2 align="middle">Overview</h2>
<p>Give a high-level overview of what you implemented in this project. Think about what you've built as a whole. Share your thoughts on what interesting things you've learned from completing the project.</p>

<h2 align="middle">Section I: Rasterization</h2>

<h3 align="middle">Part 1: Rasterizing single-color triangles</h3>

<p>In this task we enable rasterizing of single triangles of constant color which can be composed to rasterize more complex shapes. 
   Given 3 pixel coordinates to rasterize a triangle, we first determine the smallest bounding box that contains the entire triangle within the sample buffer. 
   We then go through each pixel within the triangle bounding box, and then perform the 3-line test on the center of the pixel (flooring the coordinates and offsetting by 0.5). 
   The center point is considered to be inside or on the triangle if the 3-line test determines the point is inside all of the lines or “outside” all of the lines (inverted case). 
   If the point is valid, we continue with rasterizing the point (calling the rasterize_point function), which maps the pixel in the sample buffer with the specified color. 
<br>
Our algorithm is no worse than one that checks each sample within the bounding box of the triangle because we only check pixels within the range of the 
  minimum and maximum x coordinates and minimum and maximum y coordinates. This keeps the check within the bounding box of the triangle.
 </p>
 <br>
<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="images/task1.png" align="middle" width="400px"/>
        <figcaption align="middle">screenshot of basic/test4.svg with the default viewing parameters.</figcaption>
      </td>
    </tr>
  </table>
</div>
  
<br>
<br>
<h3 align="middle">Part 2: Antialiasing triangles</h3>
  
  <p>In this task, we implement supersampling to reduce aliasing and jaggies in the simple triangle rasterization in task 1. 
    Supersampling entails sampling at a higher sampling rate than the frame buffer into our sample buffer and then using this extra sampling 
    for smoother rasterization in the frame buffer. </p>
  
  <p><b>Data Structures Modified</b>: We updated the sample_buffer to hold <i>height * width * sample_rate</i> colors, enabling us to store the color information of every single super sample. For <i>sample_rate</i> of 1, this will match the resolution of the <i>framebuffer</i>.</p>
  <p><b>Our supersampling algorithm is as follows:</b></p>
<p><ol>
  <li>In <i>rasterize_triangle</i>, we scale the input triangle coordinates by <i>sqrt(sample_rate)</i> pixels in each axis so the scaled coordinates 
    match the pixel coordinates as in the higher resolution version (the resized <i>sample_buffer</i>). We then iterate over the pixels of the triangle 
    bounding box in terms of the remapped pixel coordinates. At higher sampling rates, this means we test more points since each original (unscaled) 
    pixel was subdivided into <i>sample_rate</i> pixels. Iterating over these pixels, we conduct the 3-line-test as before and fill the color into the 
    <i>sample_buffer</i> if the pixels are within the triangle. This process should correctly map colors in the higher resolution <i>sample_buffer</i>.</li>
  <li>Since only <i>rasterize_triangle</i> had supersampling, we needed to ensure that <i>rasterize_point</i> and <i>rasterize_line</i> (which are not 
    supersampled), correctly map colors into the resized <i>sample_buffer</i>. This process was in the <i>fill_pixel</i> function. The default 
    <i>fill_pixel</i> used to directly map 1 pixel from <i>rasterize_line</i> or <i>rasterize_point</i> to a single pixel in the <i>sample_buffer</i>. 
    However, if the <i>sampling_rate</i> is now greater than 1 and we resize the <i>sample_buffer</i>, 1 pixel in <i>rasterize_line</i> or 
    <i>rasterize_point</i> actually maps to <i>sample_rate</i> number of pixels in the <i>sample_buffer</i>, so we modified <i>fill_pixel</i> to correctly
    fill in all the necessary pixels based on the <i>sampling_rate</i>.</li>
  <li>Finally, in <i>resolve_to_framebuffer<i>, we need to map our supersampled pixels back into the single pixel that actually maps to the 
    <i>framebuffer</i>. To do this, we iterate over the pixels of the <i>framebuffer</i> and pick out the <i>sample_rate<i> number of pixels in the 
    <i>sample_buffer</i> associated with the pixel. We then average the color of all these subsamples to set the pixel color of the <i>framebuffer</i>.</li>
  </ol></p>
  <p>For lines and points, supersampling won’t change anything since it is not implemented (i.e. all subsamples are the same color), but supersampling 
    is useful for toning down jaggies and any aliasing when rasterizing shapes based on triangles. It allows more consideration of the fact that the 
    one part of the pixel you sample might not reflect the entire pixel’s color. Instead pixels are colored based on how much of the pixel is actually 
    in the triangle, which allows for smoother changes in color at the edges of triangles as opposed to sharp abrupt changes without supersampling
    (only using a single center point sample) that make aliasing more prominent. Viewed at a larger scale, the image’s edges also look smoother with 
    the antialiasing.</p>
  
<p>Supersampling entailed the following modifications to the rasterization pipeline (based on steps from cs184 project 1, task 2 specification):
  <ul>
    <li>We modified the line/triangle/point rasterization step. Rasterizing the triangles for the interior image will supersample based on the 
      <i>sample_rate</i> into a <i>sample_buffer</i> that may be resized so not all pixels of the original pixel may map to the same color. 
      Additionally rasterizing points and lines will fill into multiple pixels in the <i>sample_buffer</i> based on larger sample rates (Step 3).</li>
    <li>When rasterizing the square boundary, since lines are being rasterized, the <i>sample_buffer</i> in between may map multiple pixels if the 
      sample is greater than 1 but this does not have any effect on the actual <i>framebuffer</i> since they are averaged out again (Step 4).</li>
    <li>Based on the <i>sample_rate</i> increasing, it is no longer a 1:1 mapping between the <i>sample_buffer</i> and <i>framebuffer</i>, so instead 
      of directly mapping the <i>sample_buffer</i> pixels to the <i>framebuffer</i> pixels, colors of the <i>sample_buffer</i> are averaged and then
      the <i>framebuffer</i> takes on the average color of the supersampled pixels (Step 5).</li>
  </ul>
</p>
    
<p>Below are the results of rendering <i>basic/test4.svg</i> at from sample rates of 1, 4, and 16, which show less aliasing and jaggies as the 
  <i>sample_rate</i> increases. In the zoomed in view, we can see different shades of the original color (from the supersampling and averaging) 
  on the border once the <i>sample_rate</i> is greater than 1, and comparing <i>sample_rate</i> 4 and 16 we can see a larger variation in shades 
  of the original color with <i>sample_rate</i> of 16. These extra variations of color let the border seem smoother and more accurate on the main rendered image.</p>
  
<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="images/task2_1.png" align="middle" width="400px"/>
        <figcaption align="middle">sample rate 1.</figcaption>
      </td>
      <td>
        <img src="images/task2_4.png" align="middle" width="400px"/>
        <figcaption align="middle">sample rate 4.</figcaption>
      </td>
    </tr>
    <tr>
      <td>
        <img src="images/task2_16.png" align="middle" width="400px"/>
        <figcaption align="middle">sample rate 16.</figcaption>
      </td>
    </tr>
  </table>
</div>
<br>
<br>

<h3 align="middle">Part 3: Transforms</h3>
  <p>In this task, we implemented pixel transformations including translation, scaling, and rotation. As a demonstration, we rendered the given 
    cubeman with some modifications. We gave the cubeman a fancy shirt and a hat, and had him dance with one arm up and one arm down, picking up 
    one leg, bent at the knee.</p>
  
<br>
<br>   
<h2 align="middle">Section II: Sampling</h2>

<h3 align="middle">Part 4: Barycentric coordinates</h3>

  <p>Barycentric coordinates linearly interpolate values at triangle vertices, assigning weights for each triangle vertex based on which point you are interpolating for (also could be considered proportion calculation). For any point, you can calculate weights of triangle vertices such that alpha, beta, and gamma sum up to 1. This is useful for creating color blends and gradients. 
  For example, if you look at the image aid of the triangle below, for each point inside the triangle, after calculating the weight for each vertex/color (red, green, and blue) and by combining the weighted colors together, you can get a color that is a gradient between the 3 vertices. In this case, point V has more green and blue in it, and less red, and which will be reflected in the three corresponding alpha, beta, and gamma weights.</p>
  
 <div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="images/task4_helper.png" align="middle" width="400px"/>
        <figcaption align="middle">barycentric coordinates image aid.</figcaption>
      </td>
    </tr>
    <tr>
      <td>
        <img src="images/task4.png" align="middle" width="400px"/>
        <figcaption align="middle">screenshot of svg/basic/test7.svg with default viewing parameters and sample rate 1.</figcaption>
      </td>
    </tr>
  </table>
</div> 

<h3 align="middle">Part 5: "Pixel sampling" for texture mapping</h3>

  
<p>screenshots using nearest sampling at 1 sample per pixel, nearest sampling at 16 samples per pixel, bilinear sampling at 1 sample per pixel, and bilinear sampling at 16 samples per pixel.</p>
<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="images/task5n-1.png" align="middle" width="400px"/>
        <figcaption align="middle">nearest sampling at sample rate 1.</figcaption>
      </td>
      <td>
        <img src="images/task5n-16.png" align="middle" width="400px"/>
        <figcaption align="middle">nearest sampling at sample rate 16.</figcaption>
      </td>
    </tr>
    <br>
    <tr>
      <td>
        <img src="images/task5b-1.png" align="middle" width="400px"/>
        <figcaption align="middle">bilinear sampling at sample rate 1.</figcaption>
      </td>
      <td>
        <img src="images/task5b-16.png" align="middle" width="400px"/>
        <figcaption align="middle">bilinear sampling at sample rate 16.</figcaption>
      </td>
    </tr>
  </table>
</div>
  
  
<h3 align="middle">Part 6: "Level sampling" with mipmaps for texture mapping</h3>

  <p>show us four versions of our frog image, using the combinations of L_ZERO and P_NEAREST, L_ZERO and P_LINEAR, L_NEAREST and P_NEAREST, as well as L_NEAREST and P_LINEAR</p>
  <div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="images/task6-l0-pn.png" align="middle" width="400px"/>
        <figcaption align="middle">L_ZERO and P_NEAREST.</figcaption>
      </td>
      <td>
        <img src="images/task6-l0-pl.png" align="middle" width="400px"/>
        <figcaption align="middle">L_ZERO and P_LINEAR.</figcaption>
      </td>
    </tr>
    <br>
    <tr>
      <td>
        <img src="images/task6-ln-pn.png" align="middle" width="400px"/>
        <figcaption align="middle">L_NEAREST and P_NEAREST.</figcaption>
      </td>
      <td>
        <img src="images/task6-ln-pl.png" align="middle" width="400px"/>
        <figcaption align="middle">L_NEAREST and P_LINEAR.</figcaption>
      </td>
    </tr>
  </table>
</div>


<h2 align="middle">Section III: Art Competition</h2>
<p>If you are not participating in the optional art competition, don't worry about this section!</p>

<h3 align="middle">Part 7: Draw something interesting!</h3>

</body>
</html>
